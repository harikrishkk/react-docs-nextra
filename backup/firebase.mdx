# Firebase 

- for angular, firebase is one of the best backends to choose.
- firestore noSQL and whole ecosystem is serverless
- local dev emulator 
- write apps without any server side code. ( almost )
- query database from web client. We can query, modify & display without server side code securely
- there is still a server. We can decide what type of operations are possible , allowed from client. 
- We can restrict access only to authenticated users, users with certain permissions, using firestore security rules without having backend code.
- firebase authentication ( authentication & authorization )
- firebase -> front end framework agnostic
- angularfire helps work with angular - read & modify the data & use services like auth, storage in observable way from client.
- secure file upload -> storage 
- deployment - firebase hosting - static hosting solution 
- Server side code -> firebase cloud functions - Server only logic like rest end point, payment, DB triggers etc 
- local emulator for local development
- pre defined users 
- cloud fns locally 
- protect access with guards 
- admin only screen 
- secure rest endpoint only accessible to admin users 
- DB triggers, file upload.
- Prod deployment 

[Code](https://github.com/angular-university/firebase-course)

Pre req: Node js LTS , Git, VS Code 

```js
npm ci --force 
```

### Setup firebase 

Have a firebase account. -> Add project -> Disable analytics -> Real time DB is old. Dont use it. 
Cloud firestore DB is the new one.
Create DB & start in Test mode. Select location. 
Settings -> Project settings -> Your apps ( There are no apps associated with this project ) -> Web -> Register app & check on firebase hosting 

```js 
// First run the command,
npm install firebase --force
npm install -g firebase-tools

firebase login, init, deploy // needs to be run later 

Hit continue.


// Copy the config object

const firebaseConfig = {
  apiKey: "AIzaSyCq3JPDrGQS0kCTr9vnvm8qHOpqqMC__G8",
  authDomain: "fb-demo-ang-uty.firebaseapp.com",
  projectId: "fb-demo-ang-uty",
  storageBucket: "fb-demo-ang-uty.appspot.com",
  messagingSenderId: "596913596482",
  appId: "1:596913596482:web:1d33de7c4cf1bd8ad625db"
};
```

Inside environment.ts, add the above config. With this, we connect to the database. Check app.module for wiring up. 

About Page -> Populate DB -> Check our Database. It will be pre populated 

We have a "courses" collection.

### Firestore document 

- Its a NoSQL DB based around the notion of documents & collections
- A document is a min.unit of info that we can store in DB . It looks like a JSON object . It can have primitives or references 
- map type allows us to add nested objects 
- We cannot read a single field. Instead, we read a doc. Each doc has a unique ID & a path 

### Read a document

```js 
// Register 
import { AngularFirestoreModule, USE_EMULATOR as USE_FIRESTORE_EMULATOR } from '@angular/fire/firestore';
// In module, add AngularFirestoreModule 
AngularFireModule.initializeApp(environment.firebase),
// inject  DB 
constructor(private db: AngularFirestore) {
}

onReadDoc() {
  // get an observable 
  this.db.doc("/courses/0IqCQOZjjPvih7YdzqYU").get().subscribe(docSnapshot => {
      console.log(docSnapshot.id)
      console.log(docSnapshot.data()) // full document 
  })
}
```

The firebase is schemaless. Any doc can have any set of fields & any number of fields that we need.

### Collections 

- An organized group of docs. 
- usually share the same fields, but not mandate as firestore is schemaless db 
- DB is optimized for having large collections of small docs.
- collection is a queryable group of docs.
- every doc need to belong to a particular collection & it cannot exist without a collection.
- can be nested collection.
- If we query courses, we only get courses, we wont get nested collection
- if the collection is empty, its auto deleted. 
- we simply write into a doc with a particular path. We dont need to explicitly delete it.
- every doc has unique ID. Autogenerated, guarenteed to be unique. 
- can be generated on client side & offline 
- we can also manually specify a key that we can hard code as the ID. 
- do not manually create incremental IDs 
- Instead of nesting lessons inside course, we can have them side by side and lessons have a unique courseId & link them together.
- we can nest one inside another if there is a strong relationship between them.

### Collection queries 

```js
onReadCollection() {
  // get an observable that emits 1 value & completes
  this.db.collection("courses").get().subscribe(snapshots => {
      snapshots.forEach(snap => {
          console.log(snap.id)
          console.log(snap.data())
      })
  })
}
```

adding conditions to query 

```js 
// get only 1 result 
  this.db.collection("courses/0IqCQOZjjPvih7YdzqYU/lessons", ref => ref.where("seqNo", "<=", 5).orderBy("seqNo")).get().subscribe(snapshots => {
      snapshots.forEach(snap => {
          console.log(snap.id)
          console.log(snap.data())
      })
  })
```

by default, its sorted by unique ID 

### Firestore indexes 

- much more performant than SQL Db 
- scales to large volumes of data without the need to splitting the DB into multiple DBs or sharding 
- The query performance does not depend on the total size of the data set. So independant of how many courses we have in the collection, query execution time will only depend on the size of the result set 
- If the query only return 3 courses, then the query execution time is independant if it has 10 courses or 10 million. 
- we have the performance guarentee for every query that is run against the DB 
- every query will match against performance criteria. 
- for each field, firebase creates an index for it . For 10 fields, it adds 10 indexes 
- So if we query, that query will have a matching index.
- if we try to query for 2 fields at the same time, ( seqNo, lessonsCount ). We do not have composite indexes containing the 2 fields.

```js 
// gets an error 
// Here, query targets 2 fields instead of 1. 
// We have 2 inequality range queries on seqNo & lessonsCount 
// all where clauses must be on the same field.
this.db.collection("courses", ref => ref.where("seqNo", "<=", 5)
    .where("lessonsCount", "<=", 10)
    .orderBy("seqNo")).get().subscribe(snapshots => {
        snapshots.forEach(snap => {
            console.log(snap.id)
            console.log(snap.data())
        })
    })

// query needs an index. Click on the link 
// A combined query that targets 2 fields at a time wont work as that query doesnt have corresponding index.
// Shows a modal - Create or update indexes & save. Once the status is Enabled & query is run, then it works since we created a Compound index
this.db.collection("courses", ref => ref.where("seqNo", "<=", 5)
    .where("url", "==", "angular-forms-course")
    .orderBy("seqNo")).get().subscribe(snapshots => {
        snapshots.forEach(snap => {
            console.log(snap.id)
            console.log(snap.data())
        })
    })
```
We can add excemptions to certain fields if we think it can cause performance issues. 
We can say it should not be indexed automatically. Performance guarentees & benefits come at the cost of reducing the amount of different queries we can do. In SQL, we have joins, like queries, etc . Those are not available here. 
Its a trade off. It works only when we use an ID which is not monotonically increasing. 

### CollectionGroup 

If we like to look for a particular type of lessons in all courses, if query should target all lessons, irrespective of the course they belong to, 

```js 
onReadCollectionGroup() {
  // The default index is not enough to query a collectionGroup
  // The query requires a COLLECTION_GROUP_ASC index for collection lessons and field seqNo. You can create it here: Click link & add excemption 
  // This will take some time 
  this.db.collectionGroup("lessons", ref => ref.where("seqNo", "==", 1))
      .get().subscribe(snapshots => {
          snapshots.forEach(snap => {
              console.log(snap.id)
              console.log(snap.data())
          })
      })
    }
```

### Realtime capabilities 

```js 
onReadDoc() {
  this.db.doc("/courses/0IqCQOZjjPvih7YdzqYU")
      .snapshotChanges() // for getting real time changes when the data changes in DB 
      .subscribe(docSnapshot => {
          console.log(docSnapshot.payload.id)
          console.log(docSnapshot.payload.data()) // full document 
      })
    }

this.db.collection("courses", ref => ref.where("seqNo", "<=", 5)
    .where("url", "==", "angular-forms-course")
    .orderBy("seqNo")).snapshotChanges().subscribe(snapshots => {
        snapshots.forEach(snap => {
            ..
        })
    })
```
Instead of snapshotChanges, we have valueChanges too.

```js 
 this.db.doc("/courses/0IqCQOZjjPvih7YdzqYU")
 .valueChanges()
 .pipe(
   take(1) // first()
 )
 .subscribe(data => {
   // data without ID 
   // So if we need real time updates of only the value of the document, use this 
 })
```

The snapshotChanges and valueChanges are fundamentally different from get() observable which is a short lived one. It gets one value & completes 

### Angular service layers with AngularFire & firestore 

```js filename="courses.service.ts"
import { Injectable } from "@angular/core";
import { AngularFirestore } from "@angular/fire/firestore";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Course } from "../model/course";
import { convertSnaps } from "./db-utils";

@Injectable({
  providedIn: 'root' // one instance only 
})
export class CoursesService {
  constructor(private db: AngularFirestore) {

  }

  loadCoursesByCategory(category: string): Observable<Course[]> {
    // need to add an index in DB , click link 
    return this.db.collection("courses", ref => ref.where("categories", "array-contains", category).orderBy("seqNo")).get().pipe(
      map(res => convertSnaps<Course>(res))
    )
  }
} 

// db-utils.ts 

export function convertSnaps<T>(results) {
  return <T[]>results.docs.map(snap => {
    return {
      id: snap.id,
      ...<any>snap.data()
    }
  })
}

// component 
 reloadCourses() {
    this.beginnersCourses$ = this.coursesService.loadCoursesByCategory("BEGINNER")
    this.advancedCourses$ = this.coursesService.loadCoursesByCategory("ADVANCED")
  }
```

### Local firebase emulator 

- all development locally 
- Set Default GCP resource location nam5 (us-central) first in the Project settings
- first do `firebase login` and then `firebase init`

![Authentication](/assets/firebase-init.png)

Use existing project & choose the project 

- Default for firestore rules file name 
- default for indexes 
- Typescript for cloud functions 
- No eslint 
- Go and install npm - yes 
- Public directory - dist 
- Configure SPA - yes 
- Auto build - No
- storage rules - default 
- Emulators - Authentication, Functions, Firestore , Hosting 
- Default ports 9099, 5001, 8080, 5000
- Enable UI Yes, 
- Download Emulators 

```
Your public directory is the folder (relative to your project directory) that
will contain Hosting assets to be uploaded with firebase deploy. If you
have a build process for your assets, use your build's output directory.

? What do you want to use as your public directory? dist
? Configure as a single-page app (rewrite all urls to /index.html)? Yes
? Set up automatic builds and deploys with GitHub? No
? File dist/index.html already exists. Overwrite? Yes
✔  Wrote dist/index.html

=== Storage Setup

Firebase Storage Security Rules allow you to define how and when to allow
uploads and downloads. You can keep these rules in your project directory
and publish them with firebase deploy.

? What file should be used for Storage Rules? storage.rules
? File storage.rules already exists. Overwrite? Yes
✔  Wrote storage.rules

? Which Firebase emulators do you want to set up? Press Space to select emulators, then Enter to confirm your choices.
Authentication Emulator, Functions Emulator, Firestore Emulator, Hosting Emulator
? Which port do you want to use for the auth emulator? 9099
? Which port do you want to use for the functions emulator? 5001
? Which port do you want to use for the firestore emulator? 8080
? Which port do you want to use for the hosting emulator? 5000
? Would you like to enable the Emulator UI? Yes
? Which port do you want to use for the Emulator UI (leave empty to use any available port)?
? Would you like to download the emulators now? Yes
```

We have firebaserc, firebase.json, firebase.indexes.json, firestore.rules 
The local dev project is integrated with firebase & local dev env is almost ready to be used.

In environment.ts 

```js 


export const environment = {
  production: false,
  useEmulators: true, // set this 
  firebase: {
    ...
  },
  api: {

  }
};

// app.module.ts 
import { AngularFireAuthModule, USE_EMULATOR as USE_AUTH_EMULATOR } from '@angular/fire/auth';
import { AngularFirestoreModule, USE_EMULATOR as USE_FIRESTORE_EMULATOR } from '@angular/fire/firestore';
import { AngularFireFunctionsModule, USE_EMULATOR as USE_FUNCTIONS_EMULATOR } from '@angular/fire/functions';

 providers: [
    { provide: USE_AUTH_EMULATOR, useValue: environment.useEmulators ? ['localhost', 9099] : undefined },
    { provide: USE_FIRESTORE_EMULATOR, useValue: environment.useEmulators ? ['localhost', 8080] : undefined },
    { provide: USE_FUNCTIONS_EMULATOR, useValue: environment.useEmulators ? ['localhost', 5001] : undefined }
  ],
```

Run the command `firebase emulators:start --only firestore`

```
┌─────────────────────────────────────────────────────────────┐
│ ✔  All emulators ready! It is now safe to connect your app. │
│ i  View Emulator UI at http://127.0.0.1:4000/               │
└─────────────────────────────────────────────────────────────┘

┌───────────┬────────────────┬─────────────────────────────────┐
│ Emulator  │ Host:Port      │ View in Emulator UI             │
├───────────┼────────────────┼─────────────────────────────────┤
│ Firestore │ 127.0.0.1:8080 │ http://127.0.0.1:4000/firestore │
└───────────┴────────────────┴─────────────────────────────────┘
  Emulator Hub running at 127.0.0.1:4400
  Other reserved ports: 4500, 9150
```

if we go to `http://localhost:4000/`, we see the local emulator running 
Do `npm run start` too


![Firestore initial values](/assets/fs-1.png)

Emulator data always gets reset when we stop & start them. We can export them and import them later.

```
firebase emulators:export sample-courses
i  Found running emulator hub for project fb-demo-ang-uty at http://127.0.0.1:4400
i  Creating export directory /Users/harikrishnankk/Desktop/Projects3/firebase-course/sample-courses
i  Exporting data to: /Users/harikrishnankk/Desktop/Projects3/firebase-course/sample-courses
✔  Export complete

// to load the data to local firestore emulators, 
firebase emulators:start --import sample-courses


firebase emulators:start --only firestore --import test-data

Now, we have courses and users pre populated 

```
in package json 

```
 "local-dev": "firebase emulators:start --only firestore,auth,functions --import test-data",
 "empty-emulator": "firebase emulators:start",
 "emulator": "firebase emulators:start --import test-data",
 "export": "firebase emulators:export test-data"
```

### Create course form 

```js

form = this.fb.group({
    description: ['', Validators.required],
    category: ['BEGINNER', Validators.required],
    url: ['', Validators.required],
    longDescription: ['', Validators.required],
    promo: [false],
    promoStartAt: [null],
  })

  onCreateCourse() {
    const newCourse = { ...this.form.value } as Course;
    newCourse.promoStartAt = Timestamp.fromDate(this.form.value.promoStartAt);

  }
```